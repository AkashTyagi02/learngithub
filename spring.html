<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Bézier Curve</title>
  <style>
    body {
      margin: 0;
      background: #0b1220;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
/* CANVAS SETUP */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

/* BASIC VECTOR FUNCTIONS */
function point(x, y) {
  return { x: x, y: y };
}

function add(a, b) {
  return point(a.x + b.x, a.y + b.y);
}

function sub(a, b) {
  return point(a.x - b.x, a.y - b.y);
}

function scale(v, s) {
  return point(v.x * s, v.y * s);
}

function magnitude(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

function normalize(v) {
  let m = magnitude(v);
  if (m === 0) return point(0, 0);
  return point(v.x / m, v.y / m);
}

/* CONTROL POINTS */
const P0 = point(100, canvas.height / 2);
const P3 = point(canvas.width - 100, canvas.height / 2);

let P1 = { pos: point(300, 200), vel: point(0, 0) };
let P2 = { pos: point(canvas.width - 300, 200), vel: point(0, 0) };

let mouse = point(canvas.width / 2, canvas.height / 2);

/* SPRING PARAMETERS */
const stiffness = 0.015;
const damping = 0.88;

/* SPRING PHYSICS */
function updateSpring(controlPoint, target) {
  let force = sub(target, controlPoint.pos);
  let acceleration = scale(force, stiffness);

  controlPoint.vel = add(controlPoint.vel, acceleration);
  controlPoint.vel = scale(controlPoint.vel, damping);
  controlPoint.pos = add(controlPoint.pos, controlPoint.vel);
}

/* CUBIC BÉZIER FORMULA */
function bezierPoint(t, p0, p1, p2, p3) {
  let u = 1 - t;

  let term1 = scale(p0, u * u * u);
  let term2 = scale(p1, 3 * u * u * t);
  let term3 = scale(p2, 3 * u * t * t);
  let term4 = scale(p3, t * t * t);

  return add(add(term1, term2), add(term3, term4));
}

/* BÉZIER TANGENT (DERIVATIVE) */
function bezierTangent(t, p0, p1, p2, p3) {
  let u = 1 - t;

  let term1 = scale(sub(p1, p0), 3 * u * u);
  let term2 = scale(sub(p2, p1), 6 * u * t);
  let term3 = scale(sub(p3, p2), 3 * t * t);

  return add(add(term1, term2), term3);
}

/* DRAWING FUNCTIONS */
function drawCurve() {
  ctx.beginPath();
  ctx.strokeStyle = "#38bdf8";
  ctx.lineWidth = 3;

  for (let t = 0; t <= 1; t += 0.01) {
    let p = bezierPoint(t, P0, P1.pos, P2.pos, P3);
    if (t === 0) ctx.moveTo(p.x, p.y);
    else ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();
}

function drawTangents() {
  ctx.strokeStyle = "#facc15";

  for (let t = 0; t <= 1; t += 0.1) {
    let p = bezierPoint(t, P0, P1.pos, P2.pos, P3);
    let tan = normalize(
      bezierTangent(t, P0, P1.pos, P2.pos, P3)
    );

    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x + tan.x * 25, p.y + tan.y * 25);
    ctx.stroke();
  }
}

function drawPoint(p, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
  ctx.fill();
}

/* MAIN LOOP */
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  updateSpring(P1, mouse);
  updateSpring(P2, point(canvas.width - mouse.x, mouse.y));

  drawCurve();
  drawTangents();

  drawPoint(P0, "#22c55e");
  drawPoint(P3, "#22c55e");
  drawPoint(P1.pos, "#fb7185");
  drawPoint(P2.pos, "#fb7185");

  requestAnimationFrame(animate);
}

/* INPUT HANDLING */
window.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

/* START */
animate();
</script>

</body>
</html>
